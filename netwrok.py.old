import matplotlib
matplotlib.use('TkAgg')

import matplotlib.pyplot as plt
from matplotlib.patches import Circle as CircleUI
from matplotlib.lines import Line2D
from geometry import Circle, ConvexHull
import json
import heapq


class Area(Circle):

    def _get_intersecting_groups(self, main, current, others, found):
        group = set()
        if not current.intersects(circle=main):
            return frozenset()
        group.add(current)
        for circle in others:
            if circle.intersects(circle=current):
                for already_intersected in found:
                    if not circle.intersects(circle=already_intersected):
                        return frozenset(group)
                group.add(circle)
                found.add(circle)
                others.remove(circle)
                group.union(self._get_intersecting_groups(main=main, current=current, others=others, found=found))
                others.add(circle)
        return frozenset(group)

    def get_intersecting_areas(self, areas):
        intersecting = set()
        others = set(filter(lambda a: a.intersects(circle=self), areas))
        for area in others:
            others.remove(area)
            intersecting.add(self._get_intersecting_groups(main=self, current=area, others=others, found=set()))
            others.add(area)
        return set(filter(lambda group: len(group) > 0, intersecting))


class InterestArea(Area):

    def __init__(self, center, radius, name, is_hub=False):
        super(InterestArea, self).__init__(center=center, radius=radius)
        self.name = name
        self.is_hub = is_hub

    def __repr__(self):
        return self.name


class Halo(Area):

    def __init__(self, interest_area, sensing_radius=1):
        super(Halo, self).__init__(center=interest_area.center, radius=interest_area.radius + sensing_radius)
        self.interest_area = interest_area

    def __repr__(self):
        return "Halo of " + str(self.interest_area)


class Sensor(object):

    def __init__(self, interest_area, intersection_group, sensing_radius=1):
        # TODO - for now we cheat! A sensor will be inside an interest area in one of the intersection groups
        # circles = intersection_group.union({interest_area})
        # intersection_points, inner_point = Circle.get_point_in_intersection(circles=circles)
        # center = inner_point
        # if len(intersection_points) > 2:
        #     tuples = list(map(lambda point: (point.distance(inner_point), point), intersection_points))
        #     heap = []
        #     for t in tuples:
        #         heapq.heappush(heap, t)
        #     closest_points_tuple = heapq.nsmallest(3, heap)
        #     closest_points = list(map(lambda t: t[1], closest_points_tuple))
        #     center = (ConvexHull(closest_points)).get_center()
        # super(Sensor, self).__init__(center=center, radius=sensing_radius)
        self.sensing_radius = sensing_radius
        self.interest_area = interest_area
        self.intersection_group = intersection_group


class AdhocNetwork(object):

    def __init__(self, interest_areas, sensing_radius=1):
        assert len(interest_areas) > 1, 'Interest areas need to be greater than 1'
        self.interest_areas = interest_areas
        self.sensing_radius = sensing_radius
        hubs = list(filter(lambda ia: ia.is_hub, interest_areas))
        assert len(hubs) > 0, 'There must be at least 1 hub'
        self.hub = hubs[0]
        non_hub_interest_areas = list(filter(lambda ia: not ia.is_hub, interest_areas))
        self.halos = list(map(lambda ia: Halo(interest_area=ia, sensing_radius=self.sensing_radius), self.interest_areas))
        self.available_sensor_positions = dict()
        for ia in non_hub_interest_areas:
            groups = set()
            intersecting_halo_groups = ia.get_intersecting_areas(areas=self.halos)
            for intersecting_group in intersecting_halo_groups:
                group = set(filter(lambda halo: halo.interest_area != ia, intersecting_group))
                if len(group) > 0:
                    groups.add(frozenset(group))
            self.available_sensor_positions[ia] = groups
        self.sensors = set()
        self.edges = list()
        self.initialize_network()

    def __repr__(self):
        rep = {
            'sensing_radius': self.sensing_radius,
            'hub': {
                'center': str(self.hub.center),
                'radius': self.hub.radius
            },
            'interest_areas': [
                {
                    'center': str(halo.interest_area.center),
                    'radius': halo.interest_area.radius,
                    'sensing_radius': halo.radius - halo.interest_area.radius,
                    'name': halo.interest_area.name,
                    'is_hub': halo.interest_area.is_hub
                } for halo in self.halos
            ],
            'sensors': [
                {
                    'center': str(sensor.center),
                    'sensing_radius': sensor.radius
                } for sensor in self.sensors
            ],
        }
        return json.dumps(rep)

    def initialize_network(self):
        for ia in self.interest_areas:
            if ia not in self.available_sensor_positions:
                continue
            intersection_groups = self.available_sensor_positions[ia]
            for intersection_group in intersection_groups:
                self.sensors.add(Sensor(interest_area=ia, intersection_group=set(intersection_group),
                                        sensing_radius=self.sensing_radius))

        for sensor in self.sensors:
            for other_sensor in self.sensors:
                if 0 < sensor.center.distance(point=other_sensor.center) <= self.sensing_radius:
                    self.edges.append([sensor, other_sensor])

    def plot(self, xlims, ylims, interest_areas=True, halos=True, sensors=True):
        fig, ax = plt.subplots()
        if interest_areas:
            for ia in self.interest_areas:
                color = 'blue' if not ia.is_hub else 'green'
                c = CircleUI((ia.center.x, ia.center.y), ia.radius, facecolor=color, edgecolor='black')
                c.set_alpha(0.5)
                c.set_label(ia)
                ax.add_artist(c)
        if halos:
            for halo in self.halos:
                c = CircleUI((halo.center.x, halo.center.y), halo.radius, facecolor='none', edgecolor='black')
                c.set_label(halo)
                ax.add_artist(c)
        if sensors:
            xs = []
            ys = []
            for sensor in self.sensors:
                xs.append(sensor.center.x)
                ys.append(sensor.center.y)
            ax.scatter(xs, ys, s=5, c='red', alpha=1)
            for edge in self.edges:
                sensor1 = edge[0]
                sensor2 = edge[1]
                ui_line = Line2D([sensor1.center.x, sensor2.center.x], [sensor1.center.y, sensor2.center.y], linewidth=2, color='black')
                ax.add_line(ui_line)

        ax.set_title('Adhoc Network')
        plt.xlim(xlims[0], xlims[1])
        plt.ylim(ylims[0], ylims[1])
        plt.show()

    def optimize(self, mutate, fitness, should_terminate):
        '''
        :param mutate: callable - mutate(network) mutates the sensors
        :param fitness: callable - fitness(network) calculates the fitness according to the GA
        :param should_terminate: callable - should_terminate(network, iteration) indicates if the GA should stop iterating
        :return: an optimized network according to the GA
        '''
        if not (callable(mutate) or callable(fitness) or callable(should_terminate)):
            raise ValueError('mutate, fitness and should_terminate should be callable')

        iteration = 0
        network = self
        while not should_terminate(network=network, iteration=iteration):
            pass

